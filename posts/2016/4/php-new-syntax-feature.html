<!DOCTYPE html>
<html>
<head>
<title>为PHP添加新的语法特性 - GongYong</title>
    <meta charset="utf-8">
    <meta name="keywords" content="" />
    <meta name="description" content="" />

    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link media="all" href="/css/style.css" type="text/css" rel="stylesheet" />

<link href="/css/hljs.css" rel="stylesheet"/>
</head>

<body>

<header>
    <a href='/'><strong>Gong Yong</strong></a>的Blog
    <!--
    我的 <a href="https://github.com/gywbd">GitHub</a>
    ，
    以及 <a href="/aboutMe.html">个人简介</a>。
    -->
</header>



<section class="post">

    <header>
        <h2 class="title">为PHP添加新的语法特性</h2>
        <time datetime="2016-04-20" pubdate="">
            2016-04-20
        </time>
    </header>

    <section>
        <p>这篇文章用一个简单的示例揭示了为PHP添加新的语法特性的整个过程，当然所添加的特性也只是一个小特性，没有什么实用价值，但是对于哪些想尽可能深入了解PHP底层知识的人而言却是非常有价值的。由于这篇文章基本上谈论的都是PHP的底层的东西，所以会涉及到一些C代码，以及对PHP内部的知识的运用，所以希望读者在阅读之前能够对两块东西有一些了解。</p><p>我们所要添加的特性是一个“in”操作符，如果你熟悉Python的话，你应该对这个操作符的作用会比较熟悉。我们先用几行代码来展示它的功能：</p><pre>$words = ['hello', 'world', 'foo', 'bar'];<br>var_dump('hello' in $words); // true<br>var_dump('foo' in $words);   // true<br>var_dump('blub' in $words);  // false<br>$string = 'PHP is fun!';<br>var_dump('PHP' in $string);    // true<br>var_dump('Python' in $string); // false</pre><p>从上面的代码可以看出“in”操作符可以用于判断一个参数是否在数组中，这跟in_array的功能一样（只是没有恼人的needle/haystack问题），它还可以判断一个字符串是否是另外一个字符串的子串，这个跟<i><b>false !== strpos($str2, $str1)</b></i>的作用是一样的。</p><h2>准备工作</h2><p>为了能够添加这个小特性，我们必须得修改PHP的源码，修改完之后我们还需要对它进行编译，为了能够编译PHP源码，我们首先需要安装一些必须的工具。由于我们的编译是最小化编译，不会安装任何扩展，所以我们只需要“re2c”和“bison”这两个工具。如果你的系统没有安装这两个工具，你可以使用包管理工具来安装，在Ubuntu上可以通过下面的命令来安装：</p><pre>$ sudo apt-get install re2c<br>$ sudo apt-get install bison</pre><p>下一步就使用git来clone PHP的源码库：</p><pre>// 获取源码<br>$ git clone http://git.php.net/repository/php-src.git<br>$ cd php-src<br>// 为in操作符的开发建一个分支<br>$ git checkout -b addInOperator<br>// 生成./configure脚本<br>$ ./buildconf<br>// 设置为debug模式，以及开启线程安全选项<br>$ ./configure --disable-all --enable-debug --enable-maintainer-zts<br>// 开始编译（4代表你的机器是4核的）<br>$ make -j4</pre><p>上面的命令从http://git.php.net/repository/php-src.git获取了PHP的源代码，并且创建了一个<i>addInOperator</i>的分支用于添加我们的新功能。另外需要注意到<i><b>./configure</b></i>命令中的<b>--disable-all</b>选项，这个选项会禁止安装所有非必须的扩展。</p><p>编译成功后，在sapi/cli下面会出现PHP的二进制程序，这就是我们要使用的程序，你可以测试下：</p><pre>$ sapi/cli/php -v<br>$ sapi/cli/php -r 'echo "Hallo World!";'</pre><p>我们修改了PHP源码后，你就可以使用这个二进制程序来运行新添加的特性的代码了，在我们开始之前，我们先看一下PHP是怎么运行你的脚本程序的。</p><h2>PHP脚本的生命周期</h2><p>一个PHP脚本的执行可以分成三个步骤：</p><p></p><ol><li>Tokenization (分词）<br></li><li>Parsing &amp; Compilation (语法解析和编译）<br></li><li>Execution (执行）<br></li></ol><p></p><p>下面我会介绍PHP二进制程序在每个步骤对你的PHP脚本做了什么，它是怎么实现这几个步骤的，以及我们需要修改哪些源文件来实现我们的“in”操作符的功能。</p><h3>Tokenization</h3><p>首先PHP会读取你的脚本的源代码（用PHP语言写的代码），然后把你的代码会被分解成更小的单元，这些单元也被称为“tokens（符号）”。例如 <i><b>&lt;?php echo "Hello World!"</b></i>这段PHP代码会被分解为下面的tokens：</p><pre>T_OPEN_TAG (&lt;?php )<br>T_ECHO (echo)<br>T_WHITESPACE ( )<br>T_CONSTANT_ENCAPSED_STRING ("Hello World!")<br>';'</pre><p>从上面可以看到PHP代码被分解为几个带有不同含义的语义符号，这个过程被称为tokenization，通常也叫做lexing（词法分词）或者scanning（扫描）。扫码器位于<a href="http://lxr.php.net/xref/PHP_TRUNK/Zend/zend_language_scanner.l" target="_blank">zend_language_scanner.l</a>中，这个文件位于PHP源码的Zend/目录下。</p><p>如果你向下滚动一下这个文件（大约在1000行），你可以看到一大片的token的定义，它们看起来是下面这个样子：</p><pre>&lt;ST_IN_SCRIPTING&gt;"exit" {<br>    return T_EXIT;<br>}</pre><p>上面这段符号的定义很容易理解：如果在PHP代码中碰到“<i>exit</i>”语句，lexer（词法分析器）会把它标记为<i>T_EXIT</i>。“<i>&lt;</i>”和“<i>&gt;</i>”之间的内容就是你要匹配的文字的状态。“<i>ST_IN_SCRIPTING</i>”是PHP代码的常见状态（normal state）。PHP还有一些其他的状态，例如<i>ST_DOUBLE_QUOTE</i>（字符串中的双引号），<i>ST_HEREDOC</i>（字符串的heredoc），等等。</p><p>另外一个你需要注意的是这个过程中还会指定一个语义值（semantic value）（也被称为“lower value”，或者是简写为“lval”）。我们看一个示例：</p><pre>&lt;ST_IN_SCRIPTING,ST_VAR_OFFSET&gt;{LABEL} {<br>    zend_copy_value(zendlval, yytext, yyleng);<br>    zendlval-&gt;type = IS_STRING;<br>    return T_STRING;<br>}</pre><p>“<i>{LABEL}</i> ”表示一个PHP标识符（它们的定义规则是符合正则表达式&nbsp;<i style="font-weight: bold;">[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]* </i>的字符串），上面的代码会返回一个<i>T_STRING</i>的token。此外它还会把token的文本拷贝到<i>zendlval</i>中。所以如果lexer碰到一个标识符，假设是<i>FooBarClass</i>，它会把<i>FooBarClass</i>当作是<i>lval</i>。这个过程也会应用于字符串、数字和变量名，等等。</p><p>幸运的是我们的“in”操作符的实现不需要用到太多lexer的深层知识。我们只需要把下面的代码片段添加到文件的某个地方（可以放到<i>exit</i>这个token的上面）。</p><pre>&lt;ST_IN_SCRIPTING&gt;"in" {<br>    return T_IN;<br>}</pre><p>下面我们需要让引擎知道我们添加了一个新token。我们打开<a href="http://lxr.php.net/xref/PHP_TRUNK/Zend/zend_language_parser.y" target="_blank">zend_language_parser.y</a>，然后把下面一行代码插入到这个文件中，可以放到跟上面的代码类似的位置。</p><pre>%token T_IN "in (T_IN)"</pre><p>现在你需要使用<i><b> make -j4</b></i>命令重新编译PHP源码（注意你应该在源码的顶层目录上运行这个命令，如果你使用之前的命令从代码库中clone的代码的话，那么这个目录应该是php-src目录下，而不是在Zend/目录下）。编译完之后会生成一个新的lexer，它是由re2c生成的。你可以使用下面的命令来测试你的修改是否生效：</p><pre>$ sapi/cli/php -r 'in'</pre><p>上面的命令会导致一个漂亮的解析错误：</p><pre>Parse error: syntax error, unexpected 'in' (T_IN) in Command line code on line 1</pre><p>最后还有一件事要完成，你需要重新生成会被<a href="http://php.net/tokenizer" target="_blank">tokenizer extension</a>（这个扩展会把内部的lexer应用于PHP用户代码）使用的数据。要完成这一个步，你要使用<i><b>cd</b></i>命令切换到ext/tokenizer这个目录下，然后执行<i><b>./tokenizer_data_gen.sh</b></i>命令。</p><p>执行完后，你可以执行<i><b>git diff --stat</b></i>来查看你的源码的变化，这个命令的输出看起来是下面这个样子：</p><pre>Zend/zend_language_parser.y       |    1 +<br>Zend/zend_language_scanner.c      | 1765 +++++++++++++++++++------------------<br>Zend/zend_language_scanner.l      |    4 +<br>Zend/zend_language_scanner_defs.h |    2 +-<br>ext/tokenizer/tokenizer_data.c    |    4 +-<br>5 files changed, 904 insertions(+), 872 deletions(-)</pre><p><a href="http://lxr.php.net/xref/PHP_TRUNK/Zend/zend_language_scanner.c" target="_blank">zend_language_scanner.c</a>文件就是re2c实际生成的lexer。git diff命令会显示lexer中发生的所有修改，从上面来看我们这些小小的修改导致了lexer的改动还挺大的，但这些工作都是由re2c自动完成，你完全可以不用在意。</p><h3>Parsing &amp; Compilation</h3><p>既然现在PHP已经可以把PHP用户代码（用PHP语言写的代码）转换为有意义的token了，那么PHP还必须能够识别更大的结构，像“这是一个if代码块”或者“你刚刚在此定义了一个函数”。这个过程被称为parsing（语法解析），它被定义在<a href="http://lxr.php.net/xref/PHP_TRUNK/Zend/zend_language_parser.y" target="_blank">zend_language_parser.y</a>文件中。再次强调这只是一个定义文件，真正的parser（语法解析器）是由bison生成出来的。</p><p>为了理解parser到底是怎么工作的，我们来看一个示例：</p><pre>class_statement:<br>        variable_modifiers { CG(access_type) = Z_LVAL($1.u.constant); } class_variable_declaration ';'<br>    |   class_constant_declaration ';'<br>    |   trait_use_statement<br>    |   method_modifiers function is_reference T_STRING { zend_do_begin_function_declaration(&amp;$2, &amp;$4, 1, $3.op_type, &amp;$1 TSRMLS_CC); } '('<br>           parameter_list ')' method_body { zend_do_abstract_method(&amp;$4, &amp;$1, &amp;$9 TSRMLS_CC); zend_do_end_function_declaration(&amp;$2 TSRMLS_CC); }<br>;</pre><p>现在我们先把大括号中的东西去掉，上面的代码就变成了下面的样子：</p><pre>class_statement:<br>        variable_modifiers class_variable_declaration ';'<br>    |   class_constant_declaration ';'<br>    |   trait_use_statement<br>    |   method_modifiers function is_reference T_STRING '(' parameter_list ')' method_body<br>;</pre><p>把它翻译成英文就是：</p><pre>A class statement is<br>        a variable declaration (with access modifier)<br>    or  a class constant declaration<br>    or  a trait use statement<br>    or  a method (with method modifier, optional return-by-ref, method name, parameter list and method body)<br>.</pre><p>如果你想搞清楚“method modifier（方法修饰符）”到底是什么，你可以去看method_modifier的定义，对于其他的语法元素的理解也是如此。这个过程简洁明了。</p><p>现在我们要让parser可以支持我们的“in”操作符，你只需要在“<i>expr_without_variable</i>”中添加一个新的“expr T_IN expr”规则：</p><pre>expr_without_variable:<br>    ...<br>    |   expr T_IN expr<br>    ...<br>;</pre><p>再次运行<i><b>make -j4</b></i>编译PHP源码，此时bison会重新构建(rebuild)你修改过的parser，不过这次编译不会成功，会输出下面这段难以理解的错误提示：</p><pre>conflicts: 87 shift/reduce<br>/some/path/php-src/Zend/zend_language_parser.y: expected 3 shift/reduce conflicts<br>make: *** [/some/path/php-src/Zend/zend_language_parser.c] Error 1</pre><p>上面输出的“shift/reduc”冲突表示parser在有些情况下不确定到底该干什么。PHP语法本身有三种shift/reduce冲突（例如elseif/else的模糊性）。剩下的84种冲突都是因为新添加的规则导致的。</p><p>冲突的原因是我们没有指定“in”操作符怎么跟其他的操作符配合。例如：</p><pre>// 如果你写成下面的代码<br>$foo in $bar &amp;&amp; $someOtherCond<br>// PHP是应该将它解析为：<br>($foo in $bar) &amp;&amp; $someOtherCond<br>// 还是：<br>$foo in ($bar &amp;&amp; $someOtherCond)</pre><p>上面的情况也被称为“操作符优先级“。还有一个概念是“操作符的结合性（operator associativity）”，这会用于界定&nbsp;<i><b>$foo in $bar in $baz&nbsp;</b></i>会被怎么解析。</p><p>为了解决上面出现的这种shift/reduce冲突，你只需要找到parser中的下面这行代码，然后把<i>T_IN</i>加在这行代码后面：</p><pre>%nonassoc '&lt;' T_IS_SMALLER_OR_EQUAL '&gt;' T_IS_GREATER_OR_EQUAL</pre><p>这表示“in”操作符的优先级跟“&lt;”和“&gt;”这两种形式的比较操作符相同，并且它不具有可结合性。下面的代码解释了这是什么意思：</p><pre>$foo in $bar &amp;&amp; $someOtherCond<br>// 会被解释为：<br>($foo in $bar) &amp;&amp; $someOtherCond<br>// 这是因为”&amp;&amp;”的优先级比“in”要低<br>$foo in ['abc', 'def'] + ['ghi', 'jkl']<br>// 会被解释为：<br>$foo in (['abc', 'def'] + ['ghi', 'jkl'])<br>// 这是因为”+”的优先级比”in”要高<br>$foo in $bar in $baz<br>// 这会报解析错误，因为”in”不具有结合性</pre><p>如果你再次运行<i><b>make -j4</b></i>命令，这次将不会出错。编译成功后如果你执行像<i><b> sapi/cli/php -r '"foo" in "bar";'</b></i>的命令，它不会输出任何东西，但会提示内存泄漏错误：</p><pre>[Thu Jul 26 22:33:14 2012]  Script:  '-'<br>Zend/zend_language_scanner.l(876) :  Freeing 0xB777E7AC (4 bytes), script=-<br>=== Total 1 memory leaks detected ===</pre><p>这是正常情况，因为我们还没有告诉parser应该怎么处理“in”操作符的运算。这就是上面我们展示的大括号里面的代码所负责的工作。你只需要把之前添加的<i>expr T_IN expr</i>这个规则修改为：</p><pre>expr T_IN expr { zend_do_binary_op(ZEND_IN, &amp;$$, &amp;$1, &amp;$3 TSRMLS_CC); }</pre><p>大括号中的部分被称为一个语义动作（semantic action），它会在parser匹配到这个规则（或者是这个规则的一部分）时执行。大括号中出现的看起来有些奇怪的变量<i>$$</i>, <i>$1</i>和<i>$3</i>都是节点（node）。例如<i>$1</i>表示第一个<i>expr</i>，$3表示第二个<i>expr</i>（<i>$3</i>代表的是这个规则中的第三个元素），<i>$$</i>则表示结果节点（result node）。</p><p>编译器指令（compiler instructions）被定义在<a href="http://lxr.php.net/xref/PHP_TRUNK/Zend/zend_compile.c" target="_blank">zend_compile.c</a>这个文件中（它的头文件是<a href="http://lxr.php.net/xref/PHP_TRUNK/Zend/zend_compile.h" target="_blank">zend_compile.h</a>）。例如<i>zend_do_binary_op</i>的代码看起来如下所示：</p><pre>void zend_do_binary_op(zend_uchar op, znode *result, const znode *op1, const znode *op2 TSRMLS_DC)<br>{<br>    zend_op *opline = get_next_op(CG(active_op_array) TSRMLS_CC);<br>    opline-&gt;opcode = op;<br>    opline-&gt;result_type = IS_TMP_VAR;<br>    opline-&gt;result.var = get_temporary_variable(CG(active_op_array));<br>    SET_NODE(opline-&gt;op1, op1);<br>    SET_NODE(opline-&gt;op2, op2);<br>    GET_NODE(result, opline-&gt;result);<br>}</pre><p>这段代码很容易理解，我们会在下一节讲解。这里需要强调的最后一点是大多数时候当你添加了新的语法后，你需要添加你自己的<b>zend_do_*</b>函数。而添加一个新的二位操作符是少数不用这么做的情况。如果你必须添加一个新的<b>zend_do_*</b>函数，你只需要学习下现有的这种函数就可以。绝大多数都很简单。</p><h3>Execution</h3><p>在上一节中我已经提到过compiler（编译器）会生成opcodes。我们现在仔细看看opcodes到底是什么样子的（请查看<a href="http://lxr.php.net/xref/PHP_TRUNK/Zend/zend_compile.h#106" target="_blank">zend_compile.h</a>文件）。</p><pre>struct _zend_op {<br>    opcode_handler_t handler;<br>    znode_op op1;<br>    znode_op op2;<br>    znode_op result;<br>    ulong extended_value;<br>    uint lineno;<br>    zend_uchar opcode;<br>    zend_uchar op1_type;<br>    zend_uchar op2_type;<br>    zend_uchar result_type;<br>};</pre><p>我们先简单的了解下上面的结构体中每个字段的含义：</p><p></p><ul><li><b>opcode</b> ： 这个代表会被真正执行的操作。它们可能是<i>ZEND_ADD</i>或者是<i>ZEND_SUB</i>。<br></li><li><b>op1</b>，<b>op2</b>，<b>result</b> ： 每个操作最多可以接受两个操作数（operands）（显然它可以只使用其中一个，或者甚至一个也不用），以及一个结果字段（result node）。这些字段的类型由<i>op1_type</i>，<i>op2_type</i>和<i>result_type</i>来定义。等会我们会再次讨论这些字段以及它们的类型所代表的含义。<br></li><li><b>extended_value</b> ： 这个扩展值被用于保存标志（flags）或者是一些其他的整型值（integer value）。例如变量获取指令使用这个字段来存储变量的分类（例如<i>ZEND_FETCH_LOCAL</i>或者<i>ZEND_FETCH_GLOBAL</i>）。<br></li><li><b>handler</b> ：为了优化opcode的执行，这个字段存储处理函数（handler function），它会跟opcode和操作数类型关联起来。这个字段是自动设定的，没有必要在编译期设置。<br></li><li><b>lineno</b> ： 这个你一看就应该明白。。。<br></li></ul><p></p><blockquote><i>译注：关于上面的这些字段的含义，可以进一步参考我翻译的另外一篇<a href="http://gywbd.github.io/posts/2016/2/zend-execution-engine.html" target="_blank">关于zend执行引擎的文章</a>。</i></blockquote><p><b><i>*_types</i></b>字段可以表示5种基本类型：</p><p></p><ul><li><b>IS_TMP_VAR</b> ：临时变量。通常用于表示类似<i>$foo + $bar</i>这种表达式的结果。临时变量不能共享，所以它们不需要引用计数。这种变量的生存期通常都很短，基本上都是一个指令创建了某个临时变量，然后下一个指令就会释放它。临时变量通常被写成<i>~n</i>的形式，<i>~0</i>会是第一个临时变量，<i>~1</i>是第二个，依此类推。<br></li><li><b>IS_CV</b> ： 编译变量。为了方便hash表查找，PHP会把类似于<i>$foo</i>这样的简单变量存储在一个数组里面（C数组）。更进一步编译变量同时也允许PHP对hash表进行优化。CV使用<i>!n</i>来表示（n表示编译变量数组的偏移值）。<br></li><li><b>IS_VAR</b> ： 只有简单的变量才能被转换成CV。所有其他的变量访问，例如<i>$foo['bar']</i>或者<i>$foo-&gt;bar</i>都会返回一个<i>IS_VAR</i>的变量。它本质上只是一个普通的<i>zval</i>（包含引用计数和其他所有东西）。VAR使用<i>$n</i>来表示。<br></li><li><b>IS_CONST</b> ： 常量是代码中的字面量。例如如果你在代码中写<i>"foo"</i>或者<i>3.141</i>，它们都会被编译为<i>IS_CONST</i>类型。常量会被进一步的优化，例如可以共用一个拥有相同值的zval，或者是提前计数hash值。<br></li><li><b>IS_UNUSED</b> ： 操作数没有被使用。<br></li></ul><p></p><p>我们再来看看跟操作数相关的<a href="http://lxr.php.net/xref/PHP_TRUNK/Zend/zend_compile.h#74" target="_blank">znode_op</a>的情况：</p><pre>typedef union _znode_op {<br>    zend_uint      constant;<br>    zend_uint      var;<br>    zend_uint      num;<br>    zend_ulong     hash;<br>    zend_uint      opline_num;<br>    zend_op       *jmp_addr;<br>    zval          *zv;<br>    zend_literal  *literal;<br>    void          *ptr;<br>} znode_op;</pre><p>你可以看到操作数字段的类型是一个联合体（union），联合体可以根据上下文表示其中的某个字段（而且只能表示一个）。例如zv被用于保存<i>IS_CONST</i>类型的<i>zval</i>，<i>var</i>被用于保存<i>IS_CV</i>，<i>IS_VAR</i>和<i>IS_TMP_VAR</i>变量的序号（number）。其他字段会被用在不同的特殊环境中。例如<i>jmp_addr</i>会跟<b>JMP*</b>系列指令一起使用（这些指令会用在条件语句和循环语句中）。其他的字段都只会在编译期使用，不会用在执行期（例如常量）。</p><p>现在我们已经大概清楚每个ops（操作数）大概是个什么样子了，现在唯一的问题是它们会被存放在哪里：对于每个函数（以及文件），PHP都会创建一个<a href="http://lxr.php.net/xref/PHP_TRUNK/Zend/zend_compile.h#_zend_op_array" target="_blank">zend_op_array</a>的结构体，它们会保存opcode和其他一些信息。我不想在此探讨这个结构体中的每个字段的含义，你只需要知道这个结构体的存在就可以了。</p><p>现在我们回到“in”操作符的实现上。我们已经为编译器创建了一个<i>ZEND_IN</i>的opcode。现在我们要定义这个opcode的行为。</p><p>这是在<a href="http://lxr.php.net/xref/PHP_TRUNK/Zend/zend_vm_def.h" target="_blank">zend_vm_def.h</a>文件中定义的。如果你打开这个文件，你会看到很多类似于下面这段代码的结构的定义：</p><pre>ZEND_VM_HANDLER(1, ZEND_ADD, CONST|TMP|VAR|CV, CONST|TMP|VAR|CV)<br>{<br>    USE_OPLINE<br>    zend_free_op free_op1, free_op2;<br>    SAVE_OPLINE();<br>    fast_add_function(&amp;EX_T(opline-&gt;result.var).tmp_var,<br>        GET_OP1_ZVAL_PTR(BP_VAR_R),<br>        GET_OP2_ZVAL_PTR(BP_VAR_R) TSRMLS_CC);<br>    FREE_OP1();<br>    FREE_OP2();<br>    CHECK_EXCEPTION();<br>    ZEND_VM_NEXT_OPCODE();<br>}</pre><p>定义<i>ZEND_IN</i>这个opcode的行为的代码跟上面的代码非常类似，所以我们有必要深入探讨下上面每行代码所代表的含义：</p><pre>// 头部定义了四个东西<br>//   1. 这个opcode的ID是1<br>//   2. 这个opcode的名称是ZEND_ADD<br>//   3. 这个opcode的第一个操作数可以接受CONST，TMP，VAR和CV四种类型<br>//   4. 这个opcode的第二个操作数也可以接受CONST，TMP，VAR和CV四种类型<br>ZEND_VM_HANDLER(1, ZEND_ADD, CONST|TMP|VAR|CV, CONST|TMP|VAR|CV)<br>{<br>    // USE_OPLINE表示我们想以`opline`的形式访问这个zend_op<br>    // 这对于所有要访问的操作数或者需要设定一个返回值的opcode来说是必须的<br>    USE_OPLINE<br>    // 对于每个会被访问的操作数，都必须定义一个free_op*变量<br>    // 它用于表示这个操作数是否需要释放<br>    zend_free_op free_op1, free_op2;<br>    // SAVE_OPLINE() 是实际用于把zend_op保存到`opline`的代码<br>    // USE_OPLINE 仅仅只是声明<br>    SAVE_OPLINE();<br>    // 调用快速加法函数（fast add function）<br>    fast_add_function(<br>        // 这行代码告诉这个函数把结果保存在临时结果变量中<br>        // EX_T 会以 opline-&gt;result.var表示的ID来访问临时变量<br>        &amp;EX_T(opline-&gt;result.var).tmp_var,<br>        // 获取第一个操作数进行读操作 (BP_VAR_R中的R表示读操作)<br>        GET_OP1_ZVAL_PTR(BP_VAR_R),<br>        // 获取第二个操作数进行读操作<br>        GET_OP2_ZVAL_PTR(BP_VAR_R) TSRMLS_CC);<br>    // 释放这两个操作数 (如果有必要的话)<br>    FREE_OP1();<br>    FREE_OP2();<br>    // 检查异常。异常实际上会在任何地方发生，所以你基本上必须在所有opcode中检查它们。如果你不确定<br>    // 那就尽管加上这行检查的代码<br>    CHECK_EXCEPTION();<br>    // 跳转到下一个opcode的执行<br>    ZEND_VM_NEXT_OPCODE();<br>}</pre><p>你可能已经注意到上面的代码中有很多以UPPERCASE_STUFF这种形式出现的大写字母。这是因为<i>zend_vm_def.h</i>这个文件只是一个定义文件。真正的Zend VM的代码就是从它生成的，它们被保存在<a href="http://lxr.php.net/xref/PHP_TRUNK/Zend/zend_vm_execute.h" target="_blank">zend_vm_execute.h</a>中（非常大的一个文件）。PHP有三个不同的虚拟机种类，一般被称为<i>CALL</i>（默认的），<i>GOTO</i>和<i>SWITCH</i>。因为它们的实现细节各不相同，所以定义文件中有很多类似USE_OPLINE的伪代码，这些代码之后会被不同的具体实现替代。</p><p>更进一步，所生成的VM会为所有操作数的不同类型的每一种情况的组合创建一个专有的实现。所以最终生成出来的VM的代码中不会只有一个<i>ZEND_ADD</i>函数，而是每种操作数的组合都会有一个函数，对于<i>ZEND_ADD</i>而言会生成<i>ZEND_ADD_CONST_CONST</i>，<i>ZEND_ADD_CONST_TMP</i>，<i>ZEND_ADD_CONST_VAR</i>。。。这些函数。（<i>译注：再次强调上面提到的我翻译的zend执行引擎的文章对这些知识都有更进一步的论述</i>）。</p><p>现在为了实现<i>ZEND_IN</i>这个opcode，你应该在<i>zend_vm_def.h</i>这个文件的尾部添加一个定义新的opcode的架子（definition skeleton）：</p><pre>// 159 这个数字是我的PHP源码中的下一个没被用到opcode的号码. 你也许可能要选择一个更大的数字<br>ZEND_VM_HANDLER(159, ZEND_IN, CONST|TMP|VAR|CV, CONST|TMP|VAR|CV)<br>{<br>    USE_OPLINE<br>    zend_free_op free_op1, free_op2;<br>    zval *op1, *op2;<br>    SAVE_OPLINE();<br>    op1 = GET_OP1_ZVAL_PTR(BP_VAR_R);<br>    op2 = GET_OP2_ZVAL_PTR(BP_VAR_R);<br>    /* TODO */<br>    FREE_OP1();<br>    FREE_OP2();<br>    CHECK_EXCEPTION();<br>    ZEND_VM_NEXT_OPCODE();<br>}</pre><p>上面的代码没进行任何操作，只是获取操作数，然后再马上把它们释放掉。</p><p>为了生成一个新的VM，你需要在Zend/目录下执行<i><b>php zend_vm_gen.php</b></i>这个命令。（如果这个命令执行的时候输出很多关于/e修饰符已被废弃的警告，你不要管它们）。之后你只用返回上一级目录，执行<i><b>make -j4</b></i>进行重新编译。</p><p>如果一切进展顺利，你就可以在命令行中执行<i><b>sapi/cli/php -r '"foo" in "bar";'</b></i>这个命令了，此时应该不会输出任何错误（不过也不会输出任何有用的信息）。</p><p>我们终于到了实现真正的逻辑的时候了。我们先处理字符串的情况：</p><pre>if (Z_TYPE_P(op2) == IS_STRING) {<br>    zval op1_copy;<br>    int use_copy;<br>    /* 把needle转换为字符串 */<br>    zend_make_printable_zval(op1, &amp;op1_copy, &amp;use_copy);<br>    if (use_copy) {<br>        op1 = &amp;op1_copy;<br>    }<br>    if (Z_STRLEN_P(op1) == 0) {<br>        /* 如果needles为空，则直接返回 true */<br>        ZVAL_TRUE(&amp;EX_T(opline-&gt;result.var).tmp_var);<br>    } else {<br>        char *found = zend_memnstr(<br>            Z_STRVAL_P(op2),                  /* haystack */<br>            Z_STRVAL_P(op1),                  /* needle */<br>            Z_STRLEN_P(op1),                  /* needle length */<br>            Z_STRVAL_P(op2) + Z_STRLEN_P(op2) /* haystack end ptr */<br>        );<br>        ZVAL_BOOL(&amp;EX_T(opline-&gt;result.var).tmp_var, found != NULL);<br>    }<br>    /* 释放拷贝 */<br>    if (use_copy) {<br>        zval_dtor(&amp;op1_copy);<br>    }<br>}</pre><p>上面的代码中最难理解的部分是把<i>needle</i>转换为一个字符串。这是用<i>zend_make_printable_zval</i>这个函数完成的。这个函数可能会创建一个新的<i>zval</i>，也可能不会。这也是为什么我们会把<i>op1_copy</i>和<i>use_copy</i>传给它的原因。如果这个函数拷贝了它的值，我们只需要把它放到<i>op1</i>变量中（所以我们不用在任何地方都要处理两个变量了）。最后这个拷贝需要被释放（最后三行代码做的事情）。</p><p>其他的代码都很好理解。我们使用<i>zend_memnstr</i>这个函数来判断<i>haystack</i>是否包含<i>needle</i>。如果<i>needle</i>是一个空字符串，我们只需要直接返回<i>true</i>（显然空字符串是所有字符串的一部分）。</p><p>现在当你把上面的代码添加到<b><i>/* TODO */</i></b>后，重新执行<i>zend_vm_gen.php</i>，以及再次使用<i><b>make -j4</b></i>进行编译，此时你已经搞定了in操作符的一半功能了：</p><pre>$ sapi/cli/php -r 'var_dump("foo" in "bar");'<br>bool(false)<br>$ sapi/cli/php -r 'var_dump("foo" in "foobar");'<br>bool(true)<br>$ sapi/cli/php -r 'var_dump("foo" in "hallo foo world");'<br>bool(true)<br>$ sapi/cli/php -r 'var_dump(2 in "123");'<br>bool(true)<br>$ sapi/cli/php -r 'var_dump(5 in "123");'<br>bool(false)<br>$ sapi/cli/php -r 'var_dump("" in "test");'<br>bool(true)</pre><p>下面我们再来实现数组的行为：</p><pre>else if (Z_TYPE_P(op2) == IS_ARRAY) {<br>    HashPosition pos;<br>    zval **value;<br>    /* 先假设这个值并不在数组中 */<br>    ZVAL_FALSE(&amp;EX_T(opline-&gt;result.var).tmp_var);<br>    /* 遍历数组 */<br>    zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(op2), &amp;pos);<br>    while (zend_hash_get_current_data_ex(Z_ARRVAL_P(op2), (void **) &amp;value, &amp;pos) == SUCCESS) {<br>        zval result;<br>        /* 使用==进行比较 */<br>        if (is_equal_function(&amp;result, op1, *value TSRMLS_CC) == SUCCESS &amp;&amp; Z_LVAL(result)) {<br>            ZVAL_TRUE(&amp;EX_T(opline-&gt;result.var).tmp_var);<br>            break;<br>        }<br>        zend_hash_move_forward_ex(Z_ARRVAL_P(op2), &amp;pos);<br>    }<br>}</pre><p>先对<i>haystack</i>做了一个简单的遍历，每次遍历都会跟<i>needle</i>进行比较。我们使用<i>==</i>操作符进行比较。如果你想使用<i>===</i>进行比较，则需要把<i>is_equal_function</i>替换为<i>is_identical_function</i>。</p><p>再次运行<i>zend_vm_gen.php</i>，然后执行<i><b>make -j4</b></i>进行编译，成功后in操作符的功能就完全实现了：</p><pre>$ sapi/cli/php -r 'var_dump("test" in []);'<br>bool(false)<br>$ sapi/cli/php -r 'var_dump("test" in ["foo", "bar"]);'<br>bool(false)<br>$ sapi/cli/php -r 'var_dump("test" in ["foo", "test", "bar"]);'<br>bool(true)<br>$ sapi/cli/php -r 'var_dump(0 in ["foo"]);'<br>bool(true) // because we're comparing using ==</pre><p>最后要做的一件事就是处理当第二个操作数既不是数组也不是字符串的情况。在此我只做一个简单的处理：抛出一个警告，然后返回<i>false</i>：</p><pre>else {<br>    zend_error(E_WARNING, "Right operand of in has to be either string or array");<br>    ZVAL_FALSE(&amp;EX_T(opline-&gt;result.var).tmp_var);<br>}</pre><p>再次运行zend_vm_gen.php，然后编译：</p><pre>$ sapi/cli/php -r 'var_dump("foo" in new stdClass);'<br>Warning: Right operand of in has to be either string or array in Command line code on line 1<br>bool(false)</pre><p>这也许不是最佳的做法，因为我们也许应该允许 <i>2 in 123</i>或者 <i>3.14 in 3.141</i>的情况。不过我也懒得再去实现它了：）。</p>
    </section>

    <footer>
        <!--
        <section class="followupActions">
            如果你喜欢这篇文章，你可以在下面发表评论，你可能也会有兴趣<a href="/">浏览其他文章</a> 。
        </section>
        -->
    </footer>



    <!-- <div id="SOHUCS" sid="60de67c0-06be-11e6-b697-b1e15a02344b"></div> -->
</section>




<script type="text/javascript" src="/js/jquery-1.9.1.min.js"></script>
<script src='/js/highlight.min.js'></script>
<script>
(function($){
 $(function(){
     hljs.configure({
        tabReplace: '    '
    });
     $('.post pre').each(function(i,block){
         hljs.highlightBlock(block);
     });
     //hljs.initHighlightingOnLoad();
 });

 }(jQuery));
</script>
<!--高速版，加载速度快，使用前需测试页面的兼容性-->
<!--
<script>
  (function(){
    var appid = 'cyruMmQl9',
    conf = 'prod_56838f5e72885e1172b2849c0d1c4b13';
    var doc = document,
    s = doc.createElement('script'),
    h = doc.getElementsByTagName('head')[0] || doc.head || doc.documentElement;
    s.type = 'text/javascript';
    s.charset = 'utf-8';
    s.src =  'http://assets.changyan.sohu.com/upload/changyan.js?conf='+ conf +'&appid=' + appid;
    h.insertBefore(s,h.firstChild);
    window.SCS_NO_IFRAME = true;
  })()
</script>                
-->
</body>
</html>


