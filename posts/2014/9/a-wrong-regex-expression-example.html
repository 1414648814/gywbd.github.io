<!DOCTYPE html>
<html>
<head>
<title>一个错误的正则表达式示例 - GongYong</title>
    <meta charset="utf-8">
    <meta name="keywords" content="" />
    <meta name="description" content="" />

    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link media="all" href="/css/style.css" type="text/css" rel="stylesheet" />

<link href="/css/hljs.css" rel="stylesheet"/>
</head>

<body>

<header>
    <a href='/'><strong>Gong Yong</strong></a>的Blog
    <!--
    我的 <a href="https://github.com/gywbd">GitHub</a>
    ，
    以及 <a href="/aboutMe.html">个人简介</a>。
    -->
</header>



<section class="post">

    <header>
        <h2 class="title">一个错误的正则表达式示例</h2>
        <time datetime="2014-09-01" pubdate="">
            2014-09-01
        </time>
    </header>

    <section>
        <p>最近突然对bash shell很有兴趣，读了一本书很不错的书：Linux命令行与shell脚本编程。书中有一章讲正则表达式，这一章中有一个使用正则表达式匹配美国电话号码的示例，这个示例并不正确，在此我想尝试纠正一下这个错误。</p><p>书中给出了4种合法的电话号码格式：<br></p><pre>(210)-123-2345<br>(210) 123-2345<br>210-123-2345<br>210.123.2345</pre><p>由于书中的示例的应用场景是验证表单中输入的电话号码格式是否正确，所以这个正则表达式必须是全匹配，它给出的匹配正则表达式是：</p><pre>^\(?[2-9][0-9]{2}\)?(| |-|\.)[0-9]{3}( |-|\.)[0-9]{4}$<br></pre>我们一眼就可以看出它的问题，虽然它确实可以匹配正确的电话号码，但也会匹配不正确的电话号码，像下面的电话号码：<pre>(210123-2345<br>201.123-2345<br>2011232345<br>201123 2345</pre><p>书中说电话号码的第二个分隔符可以为空格符，而且所给出的正则表达式中匹配了空格，但在它所给出的正确的电话号码的格式的示例中却没有这种格式，这里我们以书中给出的四种格式为准，也就是说第二个分隔符不能为空格符。<br></p><p>这个正则表达式的问题就是它没有考虑后面的字符的匹配跟前面的字符是否匹配有关系。如果出现了左边的圆括号"("，那么必须出现右边的圆括号")"，如果第一个分隔符是中划线"-"，那么第二个分隔符也必须为中划线。而且按照上面的正确格式的示例，电话号码的第一部分使用了括号就不能使用点"."作为分隔符。先看一个比较笨的方法，使用多选结构元字符"|"，每种格式都写一个正则表达式。</p><pre>^(\([2-9][0-9]{2}\)( |-)[0-9]{3}-[0-9]{4}|[2-9][0-9]{2}-[0-9]{3}-[0-9]{4}|[2-9][0-9]{2}\.[0-9]{3}\.[0-9]{4})$</pre><p>这里用了一个大分组，这个分组里面有三个子正则表达，它们可以匹配四种格式的正则表达式，第一个子表达式是：</p><pre>\([2-9][0-9]{2}\)( |-)[0-9]{3}-[0-9]{4}</pre><p>它会匹配前两种格式的电话号码，也就是带有括号的电话号码。第二个子表达式是：</p><pre>[2-9][0-9]{2}-[0-9]{3}-[0-9]{4}</pre><p>它会匹配第三种没有括号并且使用中划线"-"分隔的电话号码。最后一个子表达式是：</p><pre>[2-9][0-9]{2}\.[0-9]{3}\.[0-9]{4}</pre><p>它会匹配第四种没有括号并且使用点"."分隔的电话号码。</p>如果使用这个正则表达式，那么书中使用gawk进行匹配的程序就应该变成了：<br><pre>#!/bin/bash<br>#script to filter out bad phone numbers<br><br>gawk --re-interval '/^(\([2-9][0-9]{2}\)( |-)[0-9]{3}-[0-9]{4}|[2-9][0-9]{2}-[0-9]{3}-[0-9]{4}|[2-9][0-9]{2}\.[0-9]{3}\.[0-9]{4})$/{print $0}'</pre><p>如果你读到这里，可能会想：“WTF，这样就完了？”，当然不是，因为书中的示例是使用gawk来匹配正则表达式的，但是gawk支持的正则表达式的特性有限，对于这个问题这是使用gawk的最简方案。</p><p>下面我会使用支持PCRE的正则表达式来匹配，并且使用PHP语言来编写匹配程序，对于gawk等linux工具所支持的正则表达式规范，可以阅读<a target="_blank" href="http://www.infoq.com/cn/news/2011/07/regular-expressions-6-POSIX">Linux/Unix工具与正则表达式的POSIX规范</a>这篇文章。如果你想更深入的了解不同正则表达式流派的特点，以及正则表达式的发展历史的话，可以阅读那篇文章的作者翻译的<a target="_blank" href="http://www.amazon.cn/%E7%B2%BE%E9%80%9A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E6%9D%B0%E4%BD%9B%E7%91%9EE-F-%E4%BD%9B%E7%91%9E%E5%BE%B7/dp/B008UCHA58/ref=sr_1_1?ie=UTF8&amp;qid=1416986096&amp;sr=8-1&amp;keywords=%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">精通正则表达式</a>。</p><p>上面的正则表达式中的后面两个子表达式的模式是一样的，都是使用同一个分隔符将电话号码分隔起来，只是分隔符会不同而已，由于书中的正则表达式使用的是字符组，这肯定是不能保证只匹配同样的分隔符。所以为了保证肯定会匹配同一个分隔符，需要使用反向引用，使用下面的正则表达式：</p><pre>[2-9][0-9]{2}(-|\.)[0-9]{3}\1[0-9]{4}</pre><p>我们写一个php程序使用上面的正则表达式专门匹配后面两种格式的电话号码：</p><pre>&lt;?php<br>$pattern = '/^[2-9][0-9]{2}(-|\.)[0-9]{3}\1[0-9]{4}$/';<br><br>if(preg_match($pattern,$argv[1],$matches)){<br>    var_dump($matches);<br>};</pre><p>将这个php程序保存为isphone.php，然后在命令行环境中运行它：</p><pre>php isphone.php 210-123-1234</pre><p>得到的输出结果为：</p><pre>array(2) {<br>[0]=&gt;<br>string(12) "210-123-1234"<br>[1]=&gt;<br>string(1) "-"<br>}</pre><p>如果输入的电话号码为210-123.1234，则不会有结果输出，这表示匹配不成功。</p><p>这样我们的正则表达式就变成了：</p><pre>^(\([2-9][0-9]{2}\)(\ |-)[0-9]{3}-[0-9]{4}|[2-9][0-9]{2}(-|\.)[0-9]{3}\1[0-9]{4})$</pre><p>现在修改isphone.php中的正则表达式为上面的样子，注意之前使用gawk的时候的"( |-)"变成了"(\ |-)"，空格符进行了转义，在命令行中运行下面的命令：</p><pre>php isphone.php 210-123-1234</pre><p>没有结果输出，why？</p><p>这是因为我们这里用的反向引用"\1"指向的是第一个分组，也就是整个正则表达式的大分组。从左往右数，一共有三次使用了分组元字符"()"，其中第三个是"(-|\.)"，这个就是需要反向引用的，所以按照出现次序需要将"\1"改成"\3"，现在正确的正则表达式变成了下面的样子：</p><pre>^(\([2-9][0-9]{2}\)(\ |-)[0-9]{3}-[0-9]{4}|[2-9][0-9]{2}(-|\.)[0-9]{3}\3[0-9]{4})$</pre><p>除了将"\1"改成"\3"外，还有其他的方法解决这个问题，那就是使用非捕获型分组。所谓非捕获型分组就是不能进行反向引用的分组，也就是正则表达式引擎在解析正则表达式的时候不会记录圆括号中匹配的内容，这某种程度上也可以提高正则表达式的解析性能，非捕获型分组的元字符是"(?:)"，现在我们的正则表达式就变成了下面的样子：</p><pre>^(?:\([2-9][0-9]{2}\)(?:\ |-)[0-9]{3}-[0-9]{4}|[2-9][0-9]{2}(-|\.)[0-9]{3}\1[0-9]{4})$</pre><p>还能不能进一步简化呢？能！不过在这之前我们先要把这个正则表达式的写法弄得好看一点，我们会使用模式修饰符x，使用这个修饰符我们就可以把正则表达式写成多行，而且还可以在正则表达式内部加注释：</p><pre>/^(?:<br>     \([2-9][0-9]{2}\)(?:\ |-)[0-9]{3}-[0-9]{4}<br>     |&nbsp; <br>     [2-9][0-9]{2}(-|\.)[0-9]{3}\1[0-9]{4}<br>  )$<br>/x</pre><p>这样看起来就舒服多了，下面开始继续探索。</p><p>可以看到上面的正则表达式多选结构中的两个子表达式的第一部分的内容基本相似，区别就是有没有括号。如果我们能够根据判断第一个字符是不是左圆括号"("来构建正则表达式，这需要if-then-else的结构。如果第一个字符是左圆括号"("，那么匹配了第一部分的号码后就匹配右圆括号")"，刚好PCRE支持这个特性，我们先看看只匹配电话号码第一部分的正则表达式：</p><pre>/^(?:<br>    (\()?<br>    [2-9][0-9]{2}&nbsp;&nbsp; <br>    (?(1)\))<br>   )$<br>/x</pre><p>上面的正则表达式可以正确匹配"(210)"和"210"这种格式的字符串。"   (\()?"会匹配"("，  而"(?(1)\))"会判断前面的匹配是否成功，如果成功则匹配")"，如果不成功则什么都不匹配。这只是if-then，如果要使用else只需要使用符号"|"，假设我们要匹配"(210)"和"210."这两种格式的字符串，只需要对上面的正则表达式稍作修改就可以：</p><pre>/^(?:<br>    (\()?<br>    [2-9][0-9]{2}  <br>    (?(1)\)|\.)<br>   )$<br>/x</pre><p>现在判断"("是否匹配成功的部分变成了" (?(1)\)|\.)"，我们用文字来描述下整个过程：</p><pre>匹配"("<u>（这会用于后面的条件判断，记做(1)）</u><br>if("(1)"成功匹配了"(")<br>    then<br>        匹配")"<br>    else<br>        匹配"."<br>end</pre><p>需要注意的是条件判断语句的"if"的元字符是"(?)"，这个圆括号不会被捕获，但是设定匹配条件的地方"(\()?"会被捕获，这个分组的编号是1。现在开始用条件表达式来解决我们的问题吧。</p><p>我们可以通过判断第一个字符是否匹配左圆括号来构建正则表达式，下面是最终的结果：<br></p><pre>/<br>^(?:<br>    (\()?<br>    [2-9][0-9]{2}<br>    (?(1)\))<br>    (?(1)(?:\ |-)|(-|\.))<br>    [0-9]{3}<br>    (?(1)-|\2)<br>    [0-9]{4}<br>)$<br>/x</pre><p>重点关注其中的条件表达式，第一个条件表达式表示如果开头的字符是"("，那么就匹配")"，这个之前已经讲过了。第二个条件表达式是：</p><pre>(?(1)(?:\ |-)|(-|\.))</pre><p>它用到了else分支，这个条件表达式会先判断前面的"("是否匹配，如果成功匹配则匹配空格符" "或者中划线"-"，否则匹配中划线"-"或者点"."。</p><p>最后一个条件表达式：</p><pre>(?(1)-|\2)</pre><p>它也用到了else分支，如果成功匹配"("，则匹配"-"，否则匹配第二个捕获分组，也就是第二个条件表达式中的else部分"(-|\.)"，由于"(\()?"是第一个捕获分组，所以这里的反向引用用的是"\2"。</p><p>最后的PHP代码是：</p><pre>&lt;?php<br>$pattern = '/<br>    ^(?:<br>        (\()?<br>        [2-9][0-9]{2}<br>        (?(1)\))<br>        (?(1)(?:\ |-)|(-|\.))<br>        [0-9]{3}<br>        (?(1)-|\2)<br>        [0-9]{4}<br>    )$<br>/x';<br><br>if(preg_match($pattern,$argv[1],$matches)){<br>    var_dump($matches);<br>};</pre><p>写到这里，我有点怀疑这本书中没有说清楚电话号码的格式，我觉得正确的格式应该电话号码第一部分可以使用圆括号括起来，也可以不用，而中间分隔符可以是空格符" "，中划线"-"和点"."，而且两个分隔符必须一样，下面的几组电话号码都是正确的格式：</p><pre>(210)-123-1234<br>(210) 123 1234<br>(210).123.1234<br>210-123-1234<br>210 123 1234<br>210.123.1234</pre><p>不过即使这样书中给出正则表达式也是错误的，也许我可能把问题理解错了，what ever！通过编写这个正则表达式我们还是可以学到很多东西的，最后把上面列出的电话号码的匹配留给各位吧，enjoy it！<br></p><p></p>
    </section>

    <footer>
        <section class="followupActions">
            如果你喜欢这篇文章，你可以在下面发表评论，你可能也会有兴趣<a href="/">浏览其他文章</a> 。
        </section>
    </footer>



    <div id="SOHUCS" sid="bb5d9910-7249-11e4-8c7d-437bc178ad18"></div>
</section>




<script type="text/javascript" src="/js/jquery-1.9.1.min.js"></script>
<script src='/js/highlight.min.js'></script>
<script>
(function($){
 $(function(){
     hljs.configure({
        tabReplace: '    '
    });
     $('.post pre').each(function(i,block){
         hljs.highlightBlock(block);
     });
     //hljs.initHighlightingOnLoad();
 });

 }(jQuery));
</script>
<!--高速版，加载速度快，使用前需测试页面的兼容性-->
<script>
  (function(){
    var appid = 'cyruMmQl9',
    conf = 'prod_56838f5e72885e1172b2849c0d1c4b13';
    var doc = document,
    s = doc.createElement('script'),
    h = doc.getElementsByTagName('head')[0] || doc.head || doc.documentElement;
    s.type = 'text/javascript';
    s.charset = 'utf-8';
    s.src =  'http://assets.changyan.sohu.com/upload/changyan.js?conf='+ conf +'&appid=' + appid;
    h.insertBefore(s,h.firstChild);
    window.SCS_NO_IFRAME = true;
  })()
</script>                
</body>
</html>


